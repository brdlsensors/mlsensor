% Solve an Input-Output Time-Series Problem with a Time Delay Neural Network
% Script generated by Neural Time Series app.
% Created 19-Apr-2018 10:47:50
%
% This script assumes these variables are defined:
%
%   x - input time series.
%   t - target time series.

siz=290000;
sfreq=5;
lag=10;

rx=1:3;
%inp(4+lag:siz+3,1),
%x=[inp(3+lag:siz+2,1),outp(1+lag:siz,2),outp(2+lag:siz+1,2)]';%,outp(lag:siz-1,1)
%outp=outp-outp(1,:);

inpf=inp(1:sfreq:end);
outpf=outp(1:sfreq:end,:);
pospf=posp(:,1:sfreq:end,:);
siz=siz/sfreq;




x=[inpf(3+lag:siz+2,1),outpf(3+lag:siz+2,rx)]';
%x=[outpf(3+lag:siz+2,rx)]';
%t=rssq(squeeze(pospf(:,3+lag:siz+2,2))-squeeze(pospf(:,3+lag:siz+2,1)));
%t=rssq(squeeze(pospf(:,3+lag:siz+2,2))-squeeze(pospf(:,3+lag:siz+2,1)));
t=(squeeze(pospf(1,3+lag:siz+2,2))-squeeze(pospf(1,3+lag:siz+2,1)));



X = tonndata(x,true,false);
T = tonndata(t,true,false);

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.

% Create a Time Delay Network
inputDelays = 0:5:50;
hiddenLayerSize = 60;
net = timedelaynet(inputDelays,hiddenLayerSize,trainFcn);
%net = distdelaynet({1:5:50,1:2},hiddenLayerSize,trainFcn);
%net = layrecnet(1,30,trainFcn);


% Choose Input and Output Pre/Post-Processing Functions
% For a list of all processing functions type: help nnprocess
net.input.processFcns = {'removeconstantrows','mapminmax'};
net.output.processFcns = {'removeconstantrows','mapminmax'};

% Prepare the Data for Training and Simulation
% The function PREPARETS prepares timeseries data for a particular network,
% shifting time by the minimum amount to fill input states and layer
% states. Using PREPARETS allows you to keep your original time series data
% unchanged, while easily customizing it for networks with differing
% numbers of delays, with open loop or closed loop feedback modes.
[x,xi,ai,t] = preparets(net,X,T);

% Setup Division of Data for Training, Validation, Testing
% For a list of all data division functions type: help nndivision
net.divideFcn = 'dividerand';  % Divide data randomly
net.divideMode = 'time';  % Divide up every sample
net.divideParam.trainRatio = 70/100;
net.divideParam.valRatio = 15/100;
net.divideParam.testRatio = 15/100;

% Choose a Performance Function
% For a list of all performance functions type: help nnperformance
net.performFcn = 'mse';  % Mean Squared Error

% Choose Plot Functions
% For a list of all plot functions type: help nnplot
net.plotFcns = {'plotperform','plottrainstate', 'ploterrhist', ...
    'plotregression', 'plotresponse', 'ploterrcorr', 'plotinerrcorr'};

% Train the Network
[net,tr] = train(net,x,t,xi,ai);

% Test the Network
y = net(x,xi,ai);
e = gsubtract(t,y);
performance = perform(net,t,y)

% Recalculate Training, Validation and Test Performance
trainTargets = gmultiply(t,tr.trainMask);
valTargets = gmultiply(t,tr.valMask);
testTargets = gmultiply(t,tr.testMask);
trainPerformance = perform(net,trainTargets,y)
valPerformance = perform(net,valTargets,y)
testPerformance = perform(net,testTargets,y)

% % View the Network
% view(net)
% 
% % Plots
% % Uncomment these lines to enable various plots.
% %figure, plotperform(tr)
% %figure, plottrainstate(tr)
% %figure, ploterrhist(e)
% %figure, plotregression(t,y)
% %figure, plotresponse(t,y)
% %figure, ploterrcorr(e)
% %figure, plotinerrcorr(x,e)
% 
% % Step-Ahead Prediction Network
% % For some applications it helps to get the prediction a timestep early.
% % The original network returns predicted y(t+1) at the same time it is
% % given x(t+1). For some applications such as decision making, it would
% % help to have predicted y(t+1) once x(t) is available, but before the
% % actual y(t+1) occurs. The network can be made to return its output a
% % timestep early by removing one delay so that its minimal tap delay is now
% % 0 instead of 1. The new network returns the same outputs as the original
% % network, but outputs are shifted left one timestep.
% nets = removedelay(net);
% nets.name = [net.name ' - Predict One Step Ahead'];
% view(nets)
% [xs,xis,ais,ts] = preparets(nets,X,T);
% ys = nets(xs,xis,ais);
% stepAheadPerformance = perform(nets,ts,ys)


yt=cell2mat(y);
tt=cell2mat(t);
plot(yt(1,:))
hold on
plot(tt(1,:))
